// this is generated by rawtypes
const expect = @import("std").testing.expect;
pub const uv_errno_t = enum(c_int) {
    UV_E2BIG = -4093,
    UV_EACCES = -4092,
    UV_EADDRINUSE = -4091,
    UV_EADDRNOTAVAIL = -4090,
    UV_EAFNOSUPPORT = -4089,
    UV_EAGAIN = -4088,
    UV_EAI_ADDRFAMILY = -3000,
    UV_EAI_AGAIN = -3001,
    UV_EAI_BADFLAGS = -3002,
    UV_EAI_BADHINTS = -3013,
    UV_EAI_CANCELED = -3003,
    UV_EAI_FAIL = -3004,
    UV_EAI_FAMILY = -3005,
    UV_EAI_MEMORY = -3006,
    UV_EAI_NODATA = -3007,
    UV_EAI_NONAME = -3008,
    UV_EAI_OVERFLOW = -3009,
    UV_EAI_PROTOCOL = -3014,
    UV_EAI_SERVICE = -3010,
    UV_EAI_SOCKTYPE = -3011,
    UV_EALREADY = -4084,
    UV_EBADF = -4083,
    UV_EBUSY = -4082,
    UV_ECANCELED = -4081,
    UV_ECHARSET = -4080,
    UV_ECONNABORTED = -4079,
    UV_ECONNREFUSED = -4078,
    UV_ECONNRESET = -4077,
    UV_EDESTADDRREQ = -4076,
    UV_EEXIST = -4075,
    UV_EFAULT = -4074,
    UV_EFBIG = -4036,
    UV_EHOSTUNREACH = -4073,
    UV_EINTR = -4072,
    UV_EINVAL = -4071,
    UV_EIO = -4070,
    UV_EISCONN = -4069,
    UV_EISDIR = -4068,
    UV_ELOOP = -4067,
    UV_EMFILE = -4066,
    UV_EMSGSIZE = -4065,
    UV_ENAMETOOLONG = -4064,
    UV_ENETDOWN = -4063,
    UV_ENETUNREACH = -4062,
    UV_ENFILE = -4061,
    UV_ENOBUFS = -4060,
    UV_ENODEV = -4059,
    UV_ENOENT = -4058,
    UV_ENOMEM = -4057,
    UV_ENONET = -4056,
    UV_ENOPROTOOPT = -4035,
    UV_ENOSPC = -4055,
    UV_ENOSYS = -4054,
    UV_ENOTCONN = -4053,
    UV_ENOTDIR = -4052,
    UV_ENOTEMPTY = -4051,
    UV_ENOTSOCK = -4050,
    UV_ENOTSUP = -4049,
    UV_EOVERFLOW = -4026,
    UV_EPERM = -4048,
    UV_EPIPE = -4047,
    UV_EPROTO = -4046,
    UV_EPROTONOSUPPORT = -4045,
    UV_EPROTOTYPE = -4044,
    UV_ERANGE = -4034,
    UV_EROFS = -4043,
    UV_ESHUTDOWN = -4042,
    UV_ESPIPE = -4041,
    UV_ESRCH = -4040,
    UV_ETIMEDOUT = -4039,
    UV_ETXTBSY = -4038,
    UV_EXDEV = -4037,
    UV_UNKNOWN = -4094,
    UV_EOF = -4095,
    UV_ENXIO = -4033,
    UV_EMLINK = -4032,
    UV_EHOSTDOWN = -4031,
    UV_EREMOTEIO = -4030,
    UV_ENOTTY = -4029,
    UV_EFTYPE = -4028,
    UV_EILSEQ = -4027,
    UV_ESOCKTNOSUPPORT = -4025,
    UV_ERRNO_MAX = -4096,
};

pub const uv_handle_type = enum(c_int) {
    UV_UNKNOWN_HANDLE = 0,
    UV_ASYNC = 1,
    UV_CHECK = 2,
    UV_FS_EVENT = 3,
    UV_FS_POLL = 4,
    UV_HANDLE = 5,
    UV_IDLE = 6,
    UV_NAMED_PIPE = 7,
    UV_POLL = 8,
    UV_PREPARE = 9,
    UV_PROCESS = 10,
    UV_STREAM = 11,
    UV_TCP = 12,
    UV_TIMER = 13,
    UV_TTY = 14,
    UV_UDP = 15,
    UV_SIGNAL = 16,
    UV_FILE = 17,
    UV_HANDLE_TYPE_MAX = 18,
};

pub const uv_req_type = enum(c_int) {
    UV_UNKNOWN_REQ = 0,
    UV_REQ = 1,
    UV_CONNECT = 2,
    UV_WRITE = 3,
    UV_SHUTDOWN = 4,
    UV_UDP_SEND = 5,
    UV_FS = 6,
    UV_WORK = 7,
    UV_GETADDRINFO = 8,
    UV_GETNAMEINFO = 9,
    UV_RANDOM = 10,
    UV_ACCEPT = 11,
    UV_FS_EVENT_REQ = 12,
    UV_POLL_REQ = 13,
    UV_PROCESS_EXIT = 14,
    UV_READ = 15,
    UV_UDP_RECV = 16,
    UV_WAKEUP = 17,
    UV_SIGNAL_REQ = 18,
    UV_REQ_TYPE_MAX = 19,
};

pub const uv_loop_option = enum(c_int) {
    UV_LOOP_BLOCK_SIGNAL = 0,
    UV_METRICS_IDLE_TIME = 1,
};

pub const uv_run_mode = enum(c_int) {
    UV_RUN_DEFAULT = 0,
    UV_RUN_ONCE = 1,
    UV_RUN_NOWAIT = 2,
};

pub const uv_membership = enum(c_int) {
    UV_LEAVE_GROUP = 0,
    UV_JOIN_GROUP = 1,
};

pub const uv_tcp_flags = enum(c_int) {
    UV_TCP_IPV6ONLY = 1,
};

pub const uv_udp_flags = enum(c_int) {
    UV_UDP_IPV6ONLY = 1,
    UV_UDP_PARTIAL = 2,
    UV_UDP_REUSEADDR = 4,
    UV_UDP_MMSG_CHUNK = 8,
    UV_UDP_MMSG_FREE = 16,
    UV_UDP_LINUX_RECVERR = 32,
    UV_UDP_RECVMMSG = 256,
};

pub const uv_tty_mode_t = enum(c_int) {
    UV_TTY_MODE_NORMAL = 0,
    UV_TTY_MODE_RAW = 1,
    UV_TTY_MODE_IO = 2,
};

pub const uv_tty_vtermstate_t = enum(c_int) {
    UV_TTY_SUPPORTED = 0,
    UV_TTY_UNSUPPORTED = 1,
};

pub const uv_poll_event = enum(c_int) {
    UV_READABLE = 1,
    UV_WRITABLE = 2,
    UV_DISCONNECT = 4,
    UV_PRIORITIZED = 8,
};

pub const uv_stdio_flags = enum(c_int) {
    UV_IGNORE = 0,
    UV_CREATE_PIPE = 1,
    UV_INHERIT_FD = 2,
    UV_INHERIT_STREAM = 4,
    UV_READABLE_PIPE = 16,
    UV_WRITABLE_PIPE = 32,
    UV_NONBLOCK_PIPE = 64,
    UV_OVERLAPPED_PIPE = 64,
};

pub const uv_process_flags = enum(c_int) {
    UV_PROCESS_SETUID = 1,
    UV_PROCESS_SETGID = 2,
    UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = 4,
    UV_PROCESS_DETACHED = 8,
    UV_PROCESS_WINDOWS_HIDE = 16,
    UV_PROCESS_WINDOWS_HIDE_CONSOLE = 32,
    UV_PROCESS_WINDOWS_HIDE_GUI = 64,
};

pub const uv_dirent_type_t = enum(c_int) {
    UV_DIRENT_UNKNOWN = 0,
    UV_DIRENT_FILE = 1,
    UV_DIRENT_DIR = 2,
    UV_DIRENT_LINK = 3,
    UV_DIRENT_FIFO = 4,
    UV_DIRENT_SOCKET = 5,
    UV_DIRENT_CHAR = 6,
    UV_DIRENT_BLOCK = 7,
};

pub const uv_fs_type = enum(c_int) {
    UV_FS_UNKNOWN = -1,
    UV_FS_CUSTOM = 0,
    UV_FS_OPEN = 1,
    UV_FS_CLOSE = 2,
    UV_FS_READ = 3,
    UV_FS_WRITE = 4,
    UV_FS_SENDFILE = 5,
    UV_FS_STAT = 6,
    UV_FS_LSTAT = 7,
    UV_FS_FSTAT = 8,
    UV_FS_FTRUNCATE = 9,
    UV_FS_UTIME = 10,
    UV_FS_FUTIME = 11,
    UV_FS_ACCESS = 12,
    UV_FS_CHMOD = 13,
    UV_FS_FCHMOD = 14,
    UV_FS_FSYNC = 15,
    UV_FS_FDATASYNC = 16,
    UV_FS_UNLINK = 17,
    UV_FS_RMDIR = 18,
    UV_FS_MKDIR = 19,
    UV_FS_MKDTEMP = 20,
    UV_FS_RENAME = 21,
    UV_FS_SCANDIR = 22,
    UV_FS_LINK = 23,
    UV_FS_SYMLINK = 24,
    UV_FS_READLINK = 25,
    UV_FS_CHOWN = 26,
    UV_FS_FCHOWN = 27,
    UV_FS_REALPATH = 28,
    UV_FS_COPYFILE = 29,
    UV_FS_LCHOWN = 30,
    UV_FS_OPENDIR = 31,
    UV_FS_READDIR = 32,
    UV_FS_CLOSEDIR = 33,
    UV_FS_STATFS = 34,
    UV_FS_MKSTEMP = 35,
    UV_FS_LUTIME = 36,
};

pub const uv_fs_event = enum(c_int) {
    UV_RENAME = 1,
    UV_CHANGE = 2,
};

pub const uv_fs_event_flags = enum(c_int) {
    UV_FS_EVENT_WATCH_ENTRY = 1,
    UV_FS_EVENT_STAT = 2,
    UV_FS_EVENT_RECURSIVE = 4,
};

pub const uv_thread_create_flags = enum(c_int) {
    UV_THREAD_NO_FLAGS = 0,
    UV_THREAD_HAS_STACK_SIZE = 1,
};

pub const uv_loop_t = uv_loop_s;
pub const uv_handle_t = uv_handle_s;
pub const uv_dir_t = uv_dir_s;
pub const uv_stream_t = uv_stream_s;
pub const uv_tcp_t = uv_tcp_s;
pub const uv_udp_t = uv_udp_s;
pub const uv_pipe_t = uv_pipe_s;
pub const uv_tty_t = uv_tty_s;
pub const uv_poll_t = uv_poll_s;
pub const uv_timer_t = uv_timer_s;
pub const uv_prepare_t = uv_prepare_s;
pub const uv_check_t = uv_check_s;
pub const uv_idle_t = uv_idle_s;
pub const uv_async_t = uv_async_s;
pub const uv_process_t = uv_process_s;
pub const uv_fs_event_t = uv_fs_event_s;
pub const uv_fs_poll_t = uv_fs_poll_s;
pub const uv_signal_t = uv_signal_s;
pub const uv_req_t = uv_req_s;
pub const uv_getaddrinfo_t = uv_getaddrinfo_s;
pub const uv_getnameinfo_t = uv_getnameinfo_s;
pub const uv_shutdown_t = uv_shutdown_s;
pub const uv_write_t = uv_write_s;
pub const uv_connect_t = uv_connect_s;
pub const uv_udp_send_t = uv_udp_send_s;
pub const uv_fs_t = uv_fs_s;
pub const uv_work_t = uv_work_s;
pub const uv_random_t = uv_random_s;
pub const uv_env_item_t = uv_env_item_s;
pub const uv_cpu_info_t = uv_cpu_info_s;
pub const uv_interface_address_t = uv_interface_address_s;
pub const uv_dirent_t = uv_dirent_s;
pub const uv_passwd_t = uv_passwd_s;
pub const uv_utsname_t = uv_utsname_s;
pub const uv_statfs_t = uv_statfs_s;
const uv_malloc_func = fn (size: usize) callconv(.C) ?*anyopaque;
const uv_realloc_func = fn (ptr: ?*anyopaque, size: usize) callconv(.C) ?*anyopaque;
const uv_calloc_func = fn (count: usize, size: usize) callconv(.C) ?*anyopaque;
const uv_free_func = fn (ptr: ?*anyopaque) callconv(.C) void;
const uv_alloc_cb = fn (handle: ?*uv_handle_t, suggested_size: usize, buf: ?*uv_buf_t) callconv(.C) void;
const uv_read_cb = fn (stream: ?*uv_stream_t, nread: ssize_t, buf: ?*const uv_buf_t) callconv(.C) void;
const uv_write_cb = fn (req: ?*uv_write_t, status: c_int) callconv(.C) void;
const uv_connect_cb = fn (req: ?*uv_connect_t, status: c_int) callconv(.C) void;
const uv_shutdown_cb = fn (req: ?*uv_shutdown_t, status: c_int) callconv(.C) void;
const uv_connection_cb = fn (server: ?*uv_stream_t, status: c_int) callconv(.C) void;
const uv_close_cb = fn (handle: ?*uv_handle_t) callconv(.C) void;
const uv_poll_cb = fn (handle: ?*uv_poll_t, status: c_int, events: c_int) callconv(.C) void;
const uv_timer_cb = fn (handle: ?*uv_timer_t) callconv(.C) void;
const uv_async_cb = fn (handle: ?*uv_async_t) callconv(.C) void;
const uv_prepare_cb = fn (handle: ?*uv_prepare_t) callconv(.C) void;
const uv_check_cb = fn (handle: ?*uv_check_t) callconv(.C) void;
const uv_idle_cb = fn (handle: ?*uv_idle_t) callconv(.C) void;
const uv_exit_cb = fn (_3445323128: ?*uv_process_t, exit_status: c_int, term_signal: c_int) callconv(.C) void;
const uv_walk_cb = fn (handle: ?*uv_handle_t, arg: ?*anyopaque) callconv(.C) void;
const uv_fs_cb = fn (req: ?*uv_fs_t) callconv(.C) void;
const uv_work_cb = fn (req: ?*uv_work_t) callconv(.C) void;
const uv_after_work_cb = fn (req: ?*uv_work_t, status: c_int) callconv(.C) void;
pub const addrinfo = opaque {};
const uv_getaddrinfo_cb = fn (req: ?*uv_getaddrinfo_t, status: c_int, res: ?*addrinfo) callconv(.C) void;
const uv_getnameinfo_cb = fn (req: ?*uv_getnameinfo_t, status: c_int, hostname: ?[*:0]const u8, service: ?[*:0]const u8) callconv(.C) void;
const uv_random_cb = fn (req: ?*uv_random_t, status: c_int, buf: ?*anyopaque, buflen: usize) callconv(.C) void;
pub const uv_timespec_t = extern struct {
    tv_sec: c_int,
    tv_nsec: c_int,
};

pub const uv_stat_t = extern struct {
    st_dev: c_int,
    st_mode: c_int,
    st_nlink: c_int,
    st_uid: c_int,
    st_gid: c_int,
    st_rdev: c_int,
    st_ino: c_int,
    st_size: c_int,
    st_blksize: c_int,
    st_blocks: c_int,
    st_flags: c_int,
    st_gen: c_int,
    st_atim: uv_timespec_t,
    st_mtim: uv_timespec_t,
    st_ctim: uv_timespec_t,
    st_birthtim: uv_timespec_t,
};

const uv_fs_event_cb = fn (handle: ?*uv_fs_event_t, filename: ?[*:0]const u8, events: c_int, status: c_int) callconv(.C) void;
const uv_fs_poll_cb = fn (handle: ?*uv_fs_poll_t, status: c_int, prev: ?*const uv_stat_t, curr: ?*const uv_stat_t) callconv(.C) void;
const uv_signal_cb = fn (handle: ?*uv_signal_t, signum: c_int) callconv(.C) void;
pub const uv_req_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
};

pub const uv_pipe_accept_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
    pipeHandle: c_int,
    next_pending: ?*uv_pipe_accept_s,
};

pub const uv_pipe_accept_t = uv_pipe_accept_s;
pub const uv_tcp_accept_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
    accept_socket: c_int,
    accept_buffer: i8,
    event_handle: c_int,
    wait_handle: c_int,
    next_pending: ?*uv_tcp_accept_s,
};

pub const uv_tcp_accept_t = uv_tcp_accept_s;
pub const uv_read_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
    event_handle: c_int,
    wait_handle: c_int,
};

pub const uv_read_t = uv_read_s;
pub const uv_shutdown_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
    handle: ?*uv_stream_t,
    cb: *const uv_shutdown_cb,
};

pub const uv_handle_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
};

test "sizeof uv_handle_s" {
    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    try expect(@sizeOf(uv_handle_s) == 96);
}

pub const uv_stream_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    write_queue_size: usize,
    alloc_cb: *const uv_alloc_cb,
    read_cb: *const uv_read_cb,
    reqs_pending: c_uint,
    activecnt: c_int,
    read_req: uv_read_t,
    stream: extern union {
        conn: extern struct {
            write_reqs_pending: c_uint,
            shutdown_req: ?*uv_shutdown_t,
        },
        serv: extern struct {
            connection_cb: *const uv_connection_cb,
        },
    },
};

pub const uv_write_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
    cb: *const uv_write_cb,
    send_handle: ?*uv_stream_t,
    handle: ?*uv_stream_t,
    coalesced: c_int,
    write_buffer: uv_buf_t,
    event_handle: c_int,
    wait_handle: c_int,
};

pub const uv_tcp_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    write_queue_size: usize,
    alloc_cb: *const uv_alloc_cb,
    read_cb: *const uv_read_cb,
    reqs_pending: c_uint,
    activecnt: c_int,
    read_req: uv_read_t,
    stream: extern union {
        conn: extern struct {
            write_reqs_pending: c_uint,
            shutdown_req: ?*uv_shutdown_t,
        },
        serv: extern struct {
            connection_cb: *const uv_connection_cb,
        },
    },
    socket: c_int,
    delayed_error: c_int,
    tcp: extern union {
        serv: extern struct {
            accept_reqs: ?*uv_tcp_accept_t,
            processed_accepts: c_uint,
            pending_accepts: ?*uv_tcp_accept_t,
            func_acceptex: c_int,
        },
        conn: extern struct {
            read_buffer: uv_buf_t,
            func_connectex: c_int,
        },
    },
};

pub const uv_connect_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
    cb: *const uv_connect_cb,
    handle: ?*uv_stream_t,
};

const uv_udp_send_cb = fn (req: ?*uv_udp_send_t, status: c_int) callconv(.C) void;
const uv_udp_recv_cb = fn (handle: ?*uv_udp_t, nread: ssize_t, buf: ?*const uv_buf_t, addr: ?*sockaddr, flags: c_uint) callconv(.C) void;
pub const uv_udp_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    send_queue_size: usize,
    send_queue_count: usize,
    socket: c_int,
    reqs_pending: c_uint,
    activecnt: c_int,
    recv_req: uv_req_t,
    recv_buffer: uv_buf_t,
    recv_from: sockaddr_storage,
    recv_from_len: c_int,
    recv_cb: *const uv_udp_recv_cb,
    alloc_cb: *const uv_alloc_cb,
    func_wsarecv: c_int,
    func_wsarecvfrom: c_int,
};

pub const uv_udp_send_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
    handle: ?*uv_udp_t,
    cb: *const uv_udp_send_cb,
};

pub const uv_tty_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    write_queue_size: usize,
    alloc_cb: *const uv_alloc_cb,
    read_cb: *const uv_read_cb,
    reqs_pending: c_uint,
    activecnt: c_int,
    read_req: uv_read_t,
    stream: extern union {
        conn: extern struct {
            write_reqs_pending: c_uint,
            shutdown_req: ?*uv_shutdown_t,
        },
        serv: extern struct {
            connection_cb: *const uv_connection_cb,
        },
    },
    handle: c_int,
    tty: extern union {
        rd: extern struct {
            unused_: c_int,
            read_line_buffer: uv_buf_t,
            read_raw_wait: c_int,
            last_key: [8]i8,
            last_key_offset: u8,
            last_key_len: u8,
            last_utf16_high_surrogate: c_int,
            last_input_record: c_int,
        },
        wr: extern struct {
            utf8_codepoint: c_uint,
            utf8_bytes_left: u8,
            previous_eol: u8,
            ansi_parser_state: c_ushort,
            ansi_csi_argc: u8,
            ansi_csi_argv: [4]c_ushort,
            saved_position: c_int,
            saved_attributes: c_int,
        },
    },
};

pub const uv_pipe_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    write_queue_size: usize,
    alloc_cb: *const uv_alloc_cb,
    read_cb: *const uv_read_cb,
    reqs_pending: c_uint,
    activecnt: c_int,
    read_req: uv_read_t,
    stream: extern union {
        conn: extern struct {
            write_reqs_pending: c_uint,
            shutdown_req: ?*uv_shutdown_t,
        },
        serv: extern struct {
            connection_cb: *const uv_connection_cb,
        },
    },
    ipc: c_int,
    handle: c_int,
    name: ?*c_int,
    pipe: extern union {
        serv: extern struct {
            pending_instances: c_int,
            accept_reqs: ?*uv_pipe_accept_t,
            pending_accepts: ?*uv_pipe_accept_t,
        },
        conn: extern struct {
            eof_timer: ?*uv_timer_t,
            dummy: uv_write_t,
            ipc_remote_pid: c_int,
            ipc_data_frame: extern union {
                payload_remaining: c_int,
                dummy: c_int,
            },
            ipc_xfer_queue: [2]?*anyopaque,
            ipc_xfer_queue_length: c_int,
            non_overlapped_writes_tail: ?*uv_write_t,
            readfile_thread_lock: c_int,
            readfile_thread_handle: c_int,
        },
    },
};

pub const uv_poll_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    poll_cb: *const uv_poll_cb,
    socket: c_int,
    peer_socket: c_int,
    afd_poll_info_1: AFD_POLL_INFO,
    afd_poll_info_2: AFD_POLL_INFO,
    poll_req_1: uv_req_t,
    poll_req_2: uv_req_t,
    submitted_events_1: u8,
    submitted_events_2: u8,
    mask_events_1: u8,
    mask_events_2: u8,
    events: u8,
};

pub const uv_prepare_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    prepare_prev: ?*uv_prepare_t,
    prepare_next: ?*uv_prepare_t,
    prepare_cb: *const uv_prepare_cb,
};

test "sizeof uv_prepare_s" {
    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    try expect(@sizeOf(uv_prepare_s) == 120);
}

pub const uv_check_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    check_prev: ?*uv_check_t,
    check_next: ?*uv_check_t,
    check_cb: *const uv_check_cb,
};

test "sizeof uv_check_s" {
    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    try expect(@sizeOf(uv_check_s) == 120);
}

pub const uv_idle_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    idle_prev: ?*uv_idle_t,
    idle_next: ?*uv_idle_t,
    idle_cb: *const uv_idle_cb,
};

test "sizeof uv_idle_s" {
    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    try expect(@sizeOf(uv_idle_s) == 120);
}

pub const uv_async_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    async_req: uv_req_s,
    async_cb: *const uv_async_cb,
    async_sent: i8,
};

pub const uv_timer_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    heap_node: [3]?*anyopaque,
    unused: c_int,
    timeout: c_int,
    repeat: c_int,
    start_id: c_int,
    timer_cb: *const uv_timer_cb,
};

pub const uv_getaddrinfo_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
    loop: ?*uv_loop_t,
    work_req: uv__work,
    getaddrinfo_cb: *const uv_getaddrinfo_cb,
    alloc: ?*anyopaque,
    node: ?*c_int,
    service: ?*c_int,
    addrinfow: ?*addrinfoW,
    addrinfo: ?*addrinfo,
    retcode: c_int,
};

pub const uv_getnameinfo_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
    loop: ?*uv_loop_t,
    work_req: uv__work,
    getnameinfo_cb: *const uv_getnameinfo_cb,
    storage: sockaddr_storage,
    flags: c_int,
    host: i8,
    service: i8,
    retcode: c_int,
};

pub const uv_stdio_container_s = extern struct {
    flags: uv_stdio_flags,
    data: extern union {
        stream: ?*uv_stream_t,
        fd: c_int,
    },
};

test "sizeof uv_stdio_container_s" {
    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    try expect(@sizeOf(uv_stdio_container_s) == 16);
}

pub const uv_stdio_container_t = uv_stdio_container_s;
pub const uv_process_options_s = extern struct {
    exit_cb: *const uv_exit_cb,
    file: ?[*:0]const u8,
    args: ?*?*i8,
    env: ?*?*i8,
    cwd: ?[*:0]const u8,
    flags: c_uint,
    stdio_count: c_int,
    stdio: ?*uv_stdio_container_t,
    uid: uv_uid_t,
    gid: uv_gid_t,
};

test "sizeof uv_process_options_s" {
    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    try expect(@sizeOf(uv_process_options_s) == 64);
}

pub const uv_process_options_t = uv_process_options_s;
pub const uv_process_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    exit_cb: *const uv_exit_cb,
    pid: c_int,
    exit_req: uv_process_exit_s,
    child_stdio_buffer: ?*c_int,
    exit_signal: c_int,
    wait_handle: c_int,
    process_handle: c_int,
    exit_cb_pending: i8,
};

pub const uv_work_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
    loop: ?*uv_loop_t,
    work_cb: *const uv_work_cb,
    after_work_cb: *const uv_after_work_cb,
    work_req: uv__work,
};

pub const uv_cpu_times_s = extern struct {
    user: c_int,
    nice: c_int,
    sys: c_int,
    idle: c_int,
    irq: c_int,
};

pub const uv_cpu_info_s = extern struct {
    model: ?*i8,
    speed: c_int,
    cpu_times: uv_cpu_times_s,
};

pub const uv_interface_address_s = extern struct {
    name: ?*i8,
    phys_addr: [6]i8,
    is_internal: c_int,
    address: extern union {
        address4: sockaddr_in,
        address6: sockaddr_in6,
    },
    netmask: extern union {
        netmask4: sockaddr_in,
        netmask6: sockaddr_in6,
    },
};

pub const uv_passwd_s = extern struct {
    username: ?*i8,
    uid: c_uint,
    gid: c_uint,
    shell: ?*i8,
    homedir: ?*i8,
};

test "sizeof uv_passwd_s" {
    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    try expect(@sizeOf(uv_passwd_s) == 32);
}

pub const uv_utsname_s = extern struct {
    sysname: [256]i8,
    release: [256]i8,
    version: [256]i8,
    machine: [256]i8,
};

test "sizeof uv_utsname_s" {
    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    try expect(@sizeOf(uv_utsname_s) == 1024);
}

pub const uv_statfs_s = extern struct {
    f_type: c_int,
    f_bsize: c_int,
    f_blocks: c_int,
    f_bfree: c_int,
    f_bavail: c_int,
    f_files: c_int,
    f_ffree: c_int,
    f_spare: [4]c_int,
};

pub const uv_dirent_s = extern struct {
    name: ?[*:0]const u8,
    @"type": uv_dirent_type_t,
};

test "sizeof uv_dirent_s" {
    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    try expect(@sizeOf(uv_dirent_s) == 16);
}

pub const uv_timeval_t = extern struct {
    tv_sec: c_int,
    tv_usec: c_int,
};

pub const uv_timeval64_t = extern struct {
    tv_sec: c_int,
    tv_usec: c_int,
};

pub const uv_rusage_t = extern struct {
    ru_utime: uv_timeval_t,
    ru_stime: uv_timeval_t,
    ru_maxrss: c_int,
    ru_ixrss: c_int,
    ru_idrss: c_int,
    ru_isrss: c_int,
    ru_minflt: c_int,
    ru_majflt: c_int,
    ru_nswap: c_int,
    ru_inblock: c_int,
    ru_oublock: c_int,
    ru_msgsnd: c_int,
    ru_msgrcv: c_int,
    ru_nsignals: c_int,
    ru_nvcsw: c_int,
    ru_nivcsw: c_int,
};

pub const uv_env_item_s = extern struct {
    name: ?*i8,
    value: ?*i8,
};

test "sizeof uv_env_item_s" {
    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    try expect(@sizeOf(uv_env_item_s) == 16);
}

pub const uv_dir_s = extern struct {
    dirents: ?*uv_dirent_t,
    nentries: usize,
    reserved: [4]?*anyopaque,
    dir_handle: c_int,
    find_data: c_int,
};

pub const uv_fs_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
    fs_type: uv_fs_type,
    loop: ?*uv_loop_t,
    cb: *const uv_fs_cb,
    result: ssize_t,
    ptr: ?*anyopaque,
    path: ?[*:0]const u8,
    statbuf: uv_stat_t,
    work_req: uv__work,
    flags: c_int,
    sys_errno_: c_int,
    file: extern union {
        pathw: ?*c_int,
        fd: c_int,
    },
    fs: extern union {
        info: extern struct {
            mode: c_int,
            new_pathw: ?*c_int,
            file_flags: c_int,
            fd_out: c_int,
            nbufs: c_uint,
            bufs: ?*uv_buf_t,
            offset: c_int,
            bufsml: [4]uv_buf_t,
        },
        time: extern struct {
            atime: f64,
            mtime: f64,
        },
    },
};

pub const uv_fs_event_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    path: ?*i8,
    req: uv_fs_event_req_s,
    dir_handle: c_int,
    req_pending: c_int,
    cb: *const uv_fs_event_cb,
    filew: ?*c_int,
    short_filew: ?*c_int,
    dirw: ?*c_int,
    buffer: ?*i8,
};

pub const uv_fs_poll_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    poll_ctx: ?*anyopaque,
};

test "sizeof uv_fs_poll_s" {
    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    try expect(@sizeOf(uv_fs_poll_s) == 104);
}

pub const uv_signal_s = extern struct {
    data: ?*anyopaque,
    loop: ?*uv_loop_t,
    @"type": uv_handle_type,
    close_cb: *const uv_close_cb,
    handle_queue: [2]?*anyopaque,
    u: extern union {
        fd: c_int,
        reserved: [4]?*anyopaque,
    },
    endgame_next: ?*uv_handle_t,
    flags: c_uint,
    signal_cb: *const uv_signal_cb,
    signum: c_int,
    tree_entry: extern struct {
        rbe_left: ?*uv_signal_s,
        rbe_right: ?*uv_signal_s,
        rbe_parent: ?*uv_signal_s,
        rbe_color: c_int,
    },
    signal_req: uv_req_s,
    pending_signum: c_uint,
};

pub const uv_random_s = extern struct {
    data: ?*anyopaque,
    @"type": uv_req_type,
    reserved: [6]?*anyopaque,
    u: extern union {
        io: extern struct {
            overlapped: c_int,
            queued_bytes: usize,
        },
        connect: extern struct {
            result: c_int,
            pipeHandle: c_int,
            duplex_flags: c_int,
        },
    },
    next_req: ?*uv_req_s,
    loop: ?*uv_loop_t,
    status: c_int,
    buf: ?*anyopaque,
    buflen: usize,
    cb: *const uv_random_cb,
    work_req: uv__work,
};

const uv_thread_cb = fn (arg: ?*anyopaque) callconv(.C) void;
pub const uv_thread_options_s = extern struct {
    flags: c_uint,
    stack_size: usize,
};

test "sizeof uv_thread_options_s" {
    // Optional pointers are the same size as normal pointers, because pointer
    // value 0 is used as the null value.
    try expect(@sizeOf(uv_thread_options_s) == 16);
}

pub const uv_thread_options_t = uv_thread_options_s;
pub const uv_loop_s = extern struct {
    data: ?*anyopaque,
    active_handles: c_uint,
    handle_queue: [2]?*anyopaque,
    active_reqs: extern union {
        unused: ?*anyopaque,
        count: c_uint,
    },
    internal_fields: ?*anyopaque,
    stop_flag: c_uint,
    iocp: c_int,
    time: c_int,
    pending_reqs_tail: ?*uv_req_t,
    endgame_handles: ?*uv_handle_t,
    timer_heap: ?*anyopaque,
    prepare_handles: ?*uv_prepare_t,
    check_handles: ?*uv_check_t,
    idle_handles: ?*uv_idle_t,
    next_prepare_handle: ?*uv_prepare_t,
    next_check_handle: ?*uv_check_t,
    next_idle_handle: ?*uv_idle_t,
    poll_peer_sockets: [4]c_int,
    active_tcp_streams: c_uint,
    active_udp_streams: c_uint,
    timer_counter: c_int,
    wq: [2]?*anyopaque,
    wq_mutex: uv_mutex_t,
    wq_async: uv_async_t,
};

pub extern "c" fn uv_version() c_uint;
pub extern "c" fn uv_version_string() ?[*:0]const u8;
pub extern "c" fn uv_library_shutdown() void;
pub extern "c" fn uv_replace_allocator(malloc_func: *const uv_malloc_func, realloc_func: *const uv_realloc_func, calloc_func: *const uv_calloc_func, free_func: *const uv_free_func) c_int;
pub extern "c" fn uv_default_loop() ?*uv_loop_t;
pub extern "c" fn uv_loop_init(loop: ?*uv_loop_t) c_int;
pub extern "c" fn uv_loop_close(loop: ?*uv_loop_t) c_int;
pub extern "c" fn uv_loop_new() ?*uv_loop_t;
pub extern "c" fn uv_loop_delete(_2766341458: ?*uv_loop_t) void;
pub extern "c" fn uv_loop_size() usize;
pub extern "c" fn uv_loop_alive(loop: ?*const uv_loop_t) c_int;
pub extern "c" fn uv_loop_configure(loop: ?*uv_loop_t, option: uv_loop_option, ...) c_int;
pub extern "c" fn uv_loop_fork(loop: ?*uv_loop_t) c_int;
pub extern "c" fn uv_run(_2449604649: ?*uv_loop_t, mode: uv_run_mode) c_int;
pub extern "c" fn uv_stop(_3646023554: ?*uv_loop_t) void;
pub extern "c" fn uv_ref(_300284669: ?*uv_handle_t) void;
pub extern "c" fn uv_unref(_1887909548: ?*uv_handle_t) void;
pub extern "c" fn uv_has_ref(_3929338234: ?*const uv_handle_t) c_int;
pub extern "c" fn uv_update_time(_2750186990: ?*uv_loop_t) void;
pub extern "c" fn uv_now() c_int;
pub extern "c" fn uv_backend_fd(_2566699607: ?*const uv_loop_t) c_int;
pub extern "c" fn uv_backend_timeout(_1126600937: ?*const uv_loop_t) c_int;
pub extern "c" fn uv_translate_sys_error(sys_errno: c_int) c_int;
pub extern "c" fn uv_strerror(err: c_int) ?[*:0]const u8;
pub extern "c" fn uv_strerror_r(err: c_int, buf: ?*i8, buflen: usize) ?*i8;
pub extern "c" fn uv_err_name(err: c_int) ?[*:0]const u8;
pub extern "c" fn uv_err_name_r(err: c_int, buf: ?*i8, buflen: usize) ?*i8;
pub extern "c" fn uv_shutdown(req: ?*uv_shutdown_t, handle: ?*uv_stream_t, cb: *const uv_shutdown_cb) c_int;
pub extern "c" fn uv_handle_size(@"type": uv_handle_type) usize;
pub extern "c" fn uv_handle_get_type(handle: ?*const uv_handle_t) uv_handle_type;
pub extern "c" fn uv_handle_type_name(@"type": uv_handle_type) ?[*:0]const u8;
pub extern "c" fn uv_handle_get_data(handle: ?*const uv_handle_t) ?*anyopaque;
pub extern "c" fn uv_handle_get_loop(handle: ?*const uv_handle_t) ?*uv_loop_t;
pub extern "c" fn uv_handle_set_data(handle: ?*uv_handle_t, data: ?*anyopaque) void;
pub extern "c" fn uv_req_size(@"type": uv_req_type) usize;
pub extern "c" fn uv_req_get_data(req: ?*const uv_req_t) ?*anyopaque;
pub extern "c" fn uv_req_set_data(req: ?*uv_req_t, data: ?*anyopaque) void;
pub extern "c" fn uv_req_get_type(req: ?*const uv_req_t) uv_req_type;
pub extern "c" fn uv_req_type_name(@"type": uv_req_type) ?[*:0]const u8;
pub extern "c" fn uv_is_active(handle: ?*const uv_handle_t) c_int;
pub extern "c" fn uv_walk(loop: ?*uv_loop_t, walk_cb: *const uv_walk_cb, arg: ?*anyopaque) void;
pub extern "c" fn uv_print_all_handles(loop: ?*uv_loop_t, stream: ?*c_int) void;
pub extern "c" fn uv_print_active_handles(loop: ?*uv_loop_t, stream: ?*c_int) void;
pub extern "c" fn uv_close(handle: ?*uv_handle_t, close_cb: *const uv_close_cb) void;
pub extern "c" fn uv_send_buffer_size(handle: ?*uv_handle_t, value: ?*c_int) c_int;
pub extern "c" fn uv_recv_buffer_size(handle: ?*uv_handle_t, value: ?*c_int) c_int;
pub extern "c" fn uv_fileno(handle: ?*const uv_handle_t, fd: ?*uv_os_fd_t) c_int;
pub extern "c" fn uv_buf_init(base: ?*i8, len: c_uint) uv_buf_t;
pub extern "c" fn uv_pipe(fds: *uv_file, read_flags: c_int, write_flags: c_int) c_int;
pub extern "c" fn uv_socketpair(@"type": c_int, protocol: c_int, socket_vector: *uv_os_sock_t, flags0: c_int, flags1: c_int) c_int;
pub extern "c" fn uv_stream_get_write_queue_size(stream: ?*const uv_stream_t) usize;
pub extern "c" fn uv_listen(stream: ?*uv_stream_t, backlog: c_int, cb: *const uv_connection_cb) c_int;
pub extern "c" fn uv_accept(server: ?*uv_stream_t, client: ?*uv_stream_t) c_int;
pub extern "c" fn uv_read_start(_580626884: ?*uv_stream_t, alloc_cb: *const uv_alloc_cb, read_cb: *const uv_read_cb) c_int;
pub extern "c" fn uv_read_stop(_466206019: ?*uv_stream_t) c_int;
pub extern "c" fn uv_write(req: ?*uv_write_t, handle: ?*uv_stream_t, bufs: ?*const uv_buf_t, nbufs: c_uint, cb: *const uv_write_cb) c_int;
pub extern "c" fn uv_write2(req: ?*uv_write_t, handle: ?*uv_stream_t, bufs: ?*const uv_buf_t, nbufs: c_uint, send_handle: ?*uv_stream_t, cb: *const uv_write_cb) c_int;
pub extern "c" fn uv_try_write(handle: ?*uv_stream_t, bufs: ?*const uv_buf_t, nbufs: c_uint) c_int;
pub extern "c" fn uv_try_write2(handle: ?*uv_stream_t, bufs: ?*const uv_buf_t, nbufs: c_uint, send_handle: ?*uv_stream_t) c_int;
pub extern "c" fn uv_is_readable(handle: ?*const uv_stream_t) c_int;
pub extern "c" fn uv_is_writable(handle: ?*const uv_stream_t) c_int;
pub extern "c" fn uv_stream_set_blocking(handle: ?*uv_stream_t, blocking: c_int) c_int;
pub extern "c" fn uv_is_closing(handle: ?*const uv_handle_t) c_int;
pub extern "c" fn uv_tcp_init(_1329099681: ?*uv_loop_t, handle: ?*uv_tcp_t) c_int;
pub extern "c" fn uv_tcp_init_ex(_3600300300: ?*uv_loop_t, handle: ?*uv_tcp_t, flags: c_uint) c_int;
pub extern "c" fn uv_tcp_open(handle: ?*uv_tcp_t, sock: uv_os_sock_t) c_int;
pub extern "c" fn uv_tcp_nodelay(handle: ?*uv_tcp_t, enable: c_int) c_int;
pub extern "c" fn uv_tcp_keepalive(handle: ?*uv_tcp_t, enable: c_int, delay: c_uint) c_int;
pub extern "c" fn uv_tcp_simultaneous_accepts(handle: ?*uv_tcp_t, enable: c_int) c_int;
pub extern "c" fn uv_tcp_bind(handle: ?*uv_tcp_t, addr: ?*sockaddr, flags: c_uint) c_int;
pub extern "c" fn uv_tcp_getsockname(handle: ?*const uv_tcp_t, name: ?*sockaddr, namelen: ?*c_int) c_int;
pub extern "c" fn uv_tcp_getpeername(handle: ?*const uv_tcp_t, name: ?*sockaddr, namelen: ?*c_int) c_int;
pub extern "c" fn uv_tcp_close_reset(handle: ?*uv_tcp_t, close_cb: *const uv_close_cb) c_int;
pub extern "c" fn uv_tcp_connect(req: ?*uv_connect_t, handle: ?*uv_tcp_t, addr: ?*sockaddr, cb: *const uv_connect_cb) c_int;
pub extern "c" fn uv_udp_init(_1342756102: ?*uv_loop_t, handle: ?*uv_udp_t) c_int;
pub extern "c" fn uv_udp_init_ex(_672929325: ?*uv_loop_t, handle: ?*uv_udp_t, flags: c_uint) c_int;
pub extern "c" fn uv_udp_open(handle: ?*uv_udp_t, sock: uv_os_sock_t) c_int;
pub extern "c" fn uv_udp_bind(handle: ?*uv_udp_t, addr: ?*sockaddr, flags: c_uint) c_int;
pub extern "c" fn uv_udp_connect(handle: ?*uv_udp_t, addr: ?*sockaddr) c_int;
pub extern "c" fn uv_udp_getpeername(handle: ?*const uv_udp_t, name: ?*sockaddr, namelen: ?*c_int) c_int;
pub extern "c" fn uv_udp_getsockname(handle: ?*const uv_udp_t, name: ?*sockaddr, namelen: ?*c_int) c_int;
pub extern "c" fn uv_udp_set_membership(handle: ?*uv_udp_t, multicast_addr: ?[*:0]const u8, interface_addr: ?[*:0]const u8, membership: uv_membership) c_int;
pub extern "c" fn uv_udp_set_source_membership(handle: ?*uv_udp_t, multicast_addr: ?[*:0]const u8, interface_addr: ?[*:0]const u8, source_addr: ?[*:0]const u8, membership: uv_membership) c_int;
pub extern "c" fn uv_udp_set_multicast_loop(handle: ?*uv_udp_t, on: c_int) c_int;
pub extern "c" fn uv_udp_set_multicast_ttl(handle: ?*uv_udp_t, ttl: c_int) c_int;
pub extern "c" fn uv_udp_set_multicast_interface(handle: ?*uv_udp_t, interface_addr: ?[*:0]const u8) c_int;
pub extern "c" fn uv_udp_set_broadcast(handle: ?*uv_udp_t, on: c_int) c_int;
pub extern "c" fn uv_udp_set_ttl(handle: ?*uv_udp_t, ttl: c_int) c_int;
pub extern "c" fn uv_udp_send(req: ?*uv_udp_send_t, handle: ?*uv_udp_t, bufs: ?*const uv_buf_t, nbufs: c_uint, addr: ?*sockaddr, send_cb: *const uv_udp_send_cb) c_int;
pub extern "c" fn uv_udp_try_send(handle: ?*uv_udp_t, bufs: ?*const uv_buf_t, nbufs: c_uint, addr: ?*sockaddr) c_int;
pub extern "c" fn uv_udp_recv_start(handle: ?*uv_udp_t, alloc_cb: *const uv_alloc_cb, recv_cb: *const uv_udp_recv_cb) c_int;
pub extern "c" fn uv_udp_using_recvmmsg(handle: ?*const uv_udp_t) c_int;
pub extern "c" fn uv_udp_recv_stop(handle: ?*uv_udp_t) c_int;
pub extern "c" fn uv_udp_get_send_queue_size(handle: ?*const uv_udp_t) usize;
pub extern "c" fn uv_udp_get_send_queue_count(handle: ?*const uv_udp_t) usize;
pub extern "c" fn uv_tty_init(_1756536114: ?*uv_loop_t, _3804205147: ?*uv_tty_t, fd: uv_file, readable: c_int) c_int;
pub extern "c" fn uv_tty_set_mode(_1536406071: ?*uv_tty_t, mode: uv_tty_mode_t) c_int;
pub extern "c" fn uv_tty_reset_mode() c_int;
pub extern "c" fn uv_tty_get_winsize(_4099199098: ?*uv_tty_t, width: ?*c_int, height: ?*c_int) c_int;
pub extern "c" fn uv_tty_set_vterm_state(state: uv_tty_vtermstate_t) void;
pub extern "c" fn uv_tty_get_vterm_state(state: ?*uv_tty_vtermstate_t) c_int;
extern "c" fn _Z15uv_tty_set_modeP8uv_tty_si(handle: ?*uv_tty_t, mode: c_int) c_int;
pub fn uv_tty_set_mode(handle: ?*uv_tty_t, mode: c_int) c_int
{
    return _Z15uv_tty_set_modeP8uv_tty_si(handle, mode);
}
pub extern "c" fn uv_guess_handle(file: uv_file) uv_handle_type;
pub extern "c" fn uv_pipe_init(_1385939245: ?*uv_loop_t, handle: ?*uv_pipe_t, ipc: c_int) c_int;
pub extern "c" fn uv_pipe_open(_1756740833: ?*uv_pipe_t, file: uv_file) c_int;
pub extern "c" fn uv_pipe_bind(handle: ?*uv_pipe_t, name: ?[*:0]const u8) c_int;
pub extern "c" fn uv_pipe_connect(req: ?*uv_connect_t, handle: ?*uv_pipe_t, name: ?[*:0]const u8, cb: *const uv_connect_cb) void;
pub extern "c" fn uv_pipe_getsockname(handle: ?*const uv_pipe_t, buffer: ?*i8, size: ?*usize) c_int;
pub extern "c" fn uv_pipe_getpeername(handle: ?*const uv_pipe_t, buffer: ?*i8, size: ?*usize) c_int;
pub extern "c" fn uv_pipe_pending_instances(handle: ?*uv_pipe_t, count: c_int) void;
pub extern "c" fn uv_pipe_pending_count(handle: ?*uv_pipe_t) c_int;
pub extern "c" fn uv_pipe_pending_type(handle: ?*uv_pipe_t) uv_handle_type;
pub extern "c" fn uv_pipe_chmod(handle: ?*uv_pipe_t, flags: c_int) c_int;
pub extern "c" fn uv_poll_init(loop: ?*uv_loop_t, handle: ?*uv_poll_t, fd: c_int) c_int;
pub extern "c" fn uv_poll_init_socket(loop: ?*uv_loop_t, handle: ?*uv_poll_t, socket: uv_os_sock_t) c_int;
pub extern "c" fn uv_poll_start(handle: ?*uv_poll_t, events: c_int, cb: *const uv_poll_cb) c_int;
pub extern "c" fn uv_poll_stop(handle: ?*uv_poll_t) c_int;
pub extern "c" fn uv_prepare_init(_1994713338: ?*uv_loop_t, prepare: ?*uv_prepare_t) c_int;
pub extern "c" fn uv_prepare_start(prepare: ?*uv_prepare_t, cb: *const uv_prepare_cb) c_int;
pub extern "c" fn uv_prepare_stop(prepare: ?*uv_prepare_t) c_int;
pub extern "c" fn uv_check_init(_366821120: ?*uv_loop_t, check: ?*uv_check_t) c_int;
pub extern "c" fn uv_check_start(check: ?*uv_check_t, cb: *const uv_check_cb) c_int;
pub extern "c" fn uv_check_stop(check: ?*uv_check_t) c_int;
pub extern "c" fn uv_idle_init(_2867739839: ?*uv_loop_t, idle: ?*uv_idle_t) c_int;
pub extern "c" fn uv_idle_start(idle: ?*uv_idle_t, cb: *const uv_idle_cb) c_int;
pub extern "c" fn uv_idle_stop(idle: ?*uv_idle_t) c_int;
pub extern "c" fn uv_async_init(_256550904: ?*uv_loop_t, @"async": ?*uv_async_t, async_cb: *const uv_async_cb) c_int;
pub extern "c" fn uv_async_send(@"async": ?*uv_async_t) c_int;
pub extern "c" fn uv_timer_init(_3547412701: ?*uv_loop_t, handle: ?*uv_timer_t) c_int;
pub extern "c" fn uv_timer_start(handle: ?*uv_timer_t, cb: *const uv_timer_cb, timeout: c_int, repeat: c_int) c_int;
pub extern "c" fn uv_timer_stop(handle: ?*uv_timer_t) c_int;
pub extern "c" fn uv_timer_again(handle: ?*uv_timer_t) c_int;
pub extern "c" fn uv_timer_set_repeat(handle: ?*uv_timer_t, repeat: c_int) void;
pub extern "c" fn uv_timer_get_repeat() c_int;
pub extern "c" fn uv_timer_get_due_in() c_int;
pub extern "c" fn uv_getaddrinfo(loop: ?*uv_loop_t, req: ?*uv_getaddrinfo_t, getaddrinfo_cb: *const uv_getaddrinfo_cb, node: ?[*:0]const u8, service: ?[*:0]const u8, hints: ?*addrinfo) c_int;
pub extern "c" fn uv_freeaddrinfo(ai: ?*addrinfo) void;
pub extern "c" fn uv_getnameinfo(loop: ?*uv_loop_t, req: ?*uv_getnameinfo_t, getnameinfo_cb: *const uv_getnameinfo_cb, addr: ?*sockaddr, flags: c_int) c_int;
pub extern "c" fn uv_spawn(loop: ?*uv_loop_t, handle: ?*uv_process_t, options: ?*const uv_process_options_t) c_int;
pub extern "c" fn uv_process_kill(_2592798814: ?*uv_process_t, signum: c_int) c_int;
pub extern "c" fn uv_kill(pid: c_int, signum: c_int) c_int;
pub extern "c" fn uv_process_get_pid(_2670968969: ?*const uv_process_t) uv_pid_t;
pub extern "c" fn uv_queue_work(loop: ?*uv_loop_t, req: ?*uv_work_t, work_cb: *const uv_work_cb, after_work_cb: *const uv_after_work_cb) c_int;
pub extern "c" fn uv_cancel(req: ?*uv_req_t) c_int;
pub extern "c" fn uv_setup_args(argc: c_int, argv: ?*?*i8) ?*?*i8;
pub extern "c" fn uv_get_process_title(buffer: ?*i8, size: usize) c_int;
pub extern "c" fn uv_set_process_title(title: ?[*:0]const u8) c_int;
pub extern "c" fn uv_resident_set_memory(rss: ?*usize) c_int;
pub extern "c" fn uv_uptime(uptime: ?*f64) c_int;
pub extern "c" fn uv_get_osfhandle(fd: c_int) uv_os_fd_t;
pub extern "c" fn uv_open_osfhandle(os_fd: uv_os_fd_t) c_int;
pub extern "c" fn uv_getrusage(rusage: ?*uv_rusage_t) c_int;
pub extern "c" fn uv_os_homedir(buffer: ?*i8, size: ?*usize) c_int;
pub extern "c" fn uv_os_tmpdir(buffer: ?*i8, size: ?*usize) c_int;
pub extern "c" fn uv_os_get_passwd(pwd: ?*uv_passwd_t) c_int;
pub extern "c" fn uv_os_free_passwd(pwd: ?*uv_passwd_t) void;
pub extern "c" fn uv_os_getpid() uv_pid_t;
pub extern "c" fn uv_os_getppid() uv_pid_t;
pub extern "c" fn uv_os_getpriority(pid: uv_pid_t, priority: ?*c_int) c_int;
pub extern "c" fn uv_os_setpriority(pid: uv_pid_t, priority: c_int) c_int;
pub extern "c" fn uv_available_parallelism() c_uint;
pub extern "c" fn uv_cpu_info(cpu_infos: ?*?*uv_cpu_info_t, count: ?*c_int) c_int;
pub extern "c" fn uv_free_cpu_info(cpu_infos: ?*uv_cpu_info_t, count: c_int) void;
pub extern "c" fn uv_interface_addresses(addresses: ?*?*uv_interface_address_t, count: ?*c_int) c_int;
pub extern "c" fn uv_free_interface_addresses(addresses: ?*uv_interface_address_t, count: c_int) void;
pub extern "c" fn uv_os_environ(envitems: ?*?*uv_env_item_t, count: ?*c_int) c_int;
pub extern "c" fn uv_os_free_environ(envitems: ?*uv_env_item_t, count: c_int) void;
pub extern "c" fn uv_os_getenv(name: ?[*:0]const u8, buffer: ?*i8, size: ?*usize) c_int;
pub extern "c" fn uv_os_setenv(name: ?[*:0]const u8, value: ?[*:0]const u8) c_int;
pub extern "c" fn uv_os_unsetenv(name: ?[*:0]const u8) c_int;
pub extern "c" fn uv_os_gethostname(buffer: ?*i8, size: ?*usize) c_int;
pub extern "c" fn uv_os_uname(buffer: ?*uv_utsname_t) c_int;
pub extern "c" fn uv_metrics_idle_time() c_int;
pub extern "c" fn uv_fs_get_type(_3291954198: ?*const uv_fs_t) uv_fs_type;
pub extern "c" fn uv_fs_get_result(_3187561291: ?*const uv_fs_t) ssize_t;
pub extern "c" fn uv_fs_get_system_error(_1273902230: ?*const uv_fs_t) c_int;
pub extern "c" fn uv_fs_get_ptr(_2126507813: ?*const uv_fs_t) ?*anyopaque;
pub extern "c" fn uv_fs_get_path(_643997593: ?*const uv_fs_t) ?[*:0]const u8;
pub extern "c" fn uv_fs_get_statbuf(_3509312378: ?*uv_fs_t) ?*uv_stat_t;
pub extern "c" fn uv_fs_req_cleanup(req: ?*uv_fs_t) void;
pub extern "c" fn uv_fs_close(loop: ?*uv_loop_t, req: ?*uv_fs_t, file: uv_file, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_open(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, flags: c_int, mode: c_int, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_read(loop: ?*uv_loop_t, req: ?*uv_fs_t, file: uv_file, bufs: ?*const uv_buf_t, nbufs: c_uint, offset: c_int, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_unlink(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_write(loop: ?*uv_loop_t, req: ?*uv_fs_t, file: uv_file, bufs: ?*const uv_buf_t, nbufs: c_uint, offset: c_int, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_copyfile(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, new_path: ?[*:0]const u8, flags: c_int, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_mkdir(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, mode: c_int, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_mkdtemp(loop: ?*uv_loop_t, req: ?*uv_fs_t, tpl: ?[*:0]const u8, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_mkstemp(loop: ?*uv_loop_t, req: ?*uv_fs_t, tpl: ?[*:0]const u8, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_rmdir(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_scandir(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, flags: c_int, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_scandir_next(req: ?*uv_fs_t, ent: ?*uv_dirent_t) c_int;
pub extern "c" fn uv_fs_opendir(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_readdir(loop: ?*uv_loop_t, req: ?*uv_fs_t, dir: ?*uv_dir_t, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_closedir(loop: ?*uv_loop_t, req: ?*uv_fs_t, dir: ?*uv_dir_t, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_stat(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_fstat(loop: ?*uv_loop_t, req: ?*uv_fs_t, file: uv_file, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_rename(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, new_path: ?[*:0]const u8, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_fsync(loop: ?*uv_loop_t, req: ?*uv_fs_t, file: uv_file, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_fdatasync(loop: ?*uv_loop_t, req: ?*uv_fs_t, file: uv_file, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_ftruncate(loop: ?*uv_loop_t, req: ?*uv_fs_t, file: uv_file, offset: c_int, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_sendfile(loop: ?*uv_loop_t, req: ?*uv_fs_t, out_fd: uv_file, in_fd: uv_file, in_offset: c_int, length: usize, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_access(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, mode: c_int, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_chmod(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, mode: c_int, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_utime(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, atime: f64, mtime: f64, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_futime(loop: ?*uv_loop_t, req: ?*uv_fs_t, file: uv_file, atime: f64, mtime: f64, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_lutime(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, atime: f64, mtime: f64, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_lstat(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_link(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, new_path: ?[*:0]const u8, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_symlink(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, new_path: ?[*:0]const u8, flags: c_int, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_readlink(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_realpath(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_fchmod(loop: ?*uv_loop_t, req: ?*uv_fs_t, file: uv_file, mode: c_int, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_chown(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, uid: uv_uid_t, gid: uv_gid_t, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_fchown(loop: ?*uv_loop_t, req: ?*uv_fs_t, file: uv_file, uid: uv_uid_t, gid: uv_gid_t, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_lchown(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, uid: uv_uid_t, gid: uv_gid_t, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_statfs(loop: ?*uv_loop_t, req: ?*uv_fs_t, path: ?[*:0]const u8, cb: *const uv_fs_cb) c_int;
pub extern "c" fn uv_fs_poll_init(loop: ?*uv_loop_t, handle: ?*uv_fs_poll_t) c_int;
pub extern "c" fn uv_fs_poll_start(handle: ?*uv_fs_poll_t, poll_cb: *const uv_fs_poll_cb, path: ?[*:0]const u8, interval: c_uint) c_int;
pub extern "c" fn uv_fs_poll_stop(handle: ?*uv_fs_poll_t) c_int;
pub extern "c" fn uv_fs_poll_getpath(handle: ?*uv_fs_poll_t, buffer: ?*i8, size: ?*usize) c_int;
pub extern "c" fn uv_signal_init(loop: ?*uv_loop_t, handle: ?*uv_signal_t) c_int;
pub extern "c" fn uv_signal_start(handle: ?*uv_signal_t, signal_cb: *const uv_signal_cb, signum: c_int) c_int;
pub extern "c" fn uv_signal_start_oneshot(handle: ?*uv_signal_t, signal_cb: *const uv_signal_cb, signum: c_int) c_int;
pub extern "c" fn uv_signal_stop(handle: ?*uv_signal_t) c_int;
pub extern "c" fn uv_loadavg(avg: *f64) void;
pub extern "c" fn uv_fs_event_init(loop: ?*uv_loop_t, handle: ?*uv_fs_event_t) c_int;
pub extern "c" fn uv_fs_event_start(handle: ?*uv_fs_event_t, cb: *const uv_fs_event_cb, path: ?[*:0]const u8, flags: c_uint) c_int;
pub extern "c" fn uv_fs_event_stop(handle: ?*uv_fs_event_t) c_int;
pub extern "c" fn uv_fs_event_getpath(handle: ?*uv_fs_event_t, buffer: ?*i8, size: ?*usize) c_int;
pub extern "c" fn uv_ip4_addr(ip: ?[*:0]const u8, port: c_int, addr: ?*sockaddr_in) c_int;
pub extern "c" fn uv_ip6_addr(ip: ?[*:0]const u8, port: c_int, addr: ?*sockaddr_in6) c_int;
pub extern "c" fn uv_ip4_name(src: ?*sockaddr_in, dst: ?*i8, size: usize) c_int;
pub extern "c" fn uv_ip6_name(src: ?*sockaddr_in6, dst: ?*i8, size: usize) c_int;
pub extern "c" fn uv_ip_name(src: ?*sockaddr, dst: ?*i8, size: usize) c_int;
pub extern "c" fn uv_inet_ntop(af: c_int, src: ?*const anyopaque, dst: ?*i8, size: usize) c_int;
pub extern "c" fn uv_inet_pton(af: c_int, src: ?[*:0]const u8, dst: ?*anyopaque) c_int;
pub extern "c" fn uv_random(loop: ?*uv_loop_t, req: ?*uv_random_t, buf: ?*anyopaque, buflen: usize, flags: c_uint, cb: *const uv_random_cb) c_int;
pub extern "c" fn uv_if_indextoname(ifindex: c_uint, buffer: ?*i8, size: ?*usize) c_int;
pub extern "c" fn uv_if_indextoiid(ifindex: c_uint, buffer: ?*i8, size: ?*usize) c_int;
pub extern "c" fn uv_exepath(buffer: ?*i8, size: ?*usize) c_int;
pub extern "c" fn uv_cwd(buffer: ?*i8, size: ?*usize) c_int;
pub extern "c" fn uv_chdir(dir: ?[*:0]const u8) c_int;
pub extern "c" fn uv_get_free_memory() c_int;
pub extern "c" fn uv_get_total_memory() c_int;
pub extern "c" fn uv_get_constrained_memory() c_int;
pub extern "c" fn uv_hrtime() c_int;
pub extern "c" fn uv_sleep(msec: c_uint) void;
pub extern "c" fn uv_disable_stdio_inheritance() void;
pub extern "c" fn uv_dlopen(filename: ?[*:0]const u8, lib: ?*uv_lib_t) c_int;
pub extern "c" fn uv_dlclose(lib: ?*uv_lib_t) void;
pub extern "c" fn uv_dlsym(lib: ?*uv_lib_t, name: ?[*:0]const u8, ptr: ?*?*anyopaque) c_int;
pub extern "c" fn uv_dlerror(lib: ?*const uv_lib_t) ?[*:0]const u8;
pub extern "c" fn uv_mutex_init(handle: ?*uv_mutex_t) c_int;
pub extern "c" fn uv_mutex_init_recursive(handle: ?*uv_mutex_t) c_int;
pub extern "c" fn uv_mutex_destroy(handle: ?*uv_mutex_t) void;
pub extern "c" fn uv_mutex_lock(handle: ?*uv_mutex_t) void;
pub extern "c" fn uv_mutex_trylock(handle: ?*uv_mutex_t) c_int;
pub extern "c" fn uv_mutex_unlock(handle: ?*uv_mutex_t) void;
pub extern "c" fn uv_rwlock_init(rwlock: ?*uv_rwlock_t) c_int;
pub extern "c" fn uv_rwlock_destroy(rwlock: ?*uv_rwlock_t) void;
pub extern "c" fn uv_rwlock_rdlock(rwlock: ?*uv_rwlock_t) void;
pub extern "c" fn uv_rwlock_tryrdlock(rwlock: ?*uv_rwlock_t) c_int;
pub extern "c" fn uv_rwlock_rdunlock(rwlock: ?*uv_rwlock_t) void;
pub extern "c" fn uv_rwlock_wrlock(rwlock: ?*uv_rwlock_t) void;
pub extern "c" fn uv_rwlock_trywrlock(rwlock: ?*uv_rwlock_t) c_int;
pub extern "c" fn uv_rwlock_wrunlock(rwlock: ?*uv_rwlock_t) void;
pub extern "c" fn uv_sem_init(sem: ?*uv_sem_t, value: c_uint) c_int;
pub extern "c" fn uv_sem_destroy(sem: ?*uv_sem_t) void;
pub extern "c" fn uv_sem_post(sem: ?*uv_sem_t) void;
pub extern "c" fn uv_sem_wait(sem: ?*uv_sem_t) void;
pub extern "c" fn uv_sem_trywait(sem: ?*uv_sem_t) c_int;
pub extern "c" fn uv_cond_init(cond: ?*uv_cond_t) c_int;
pub extern "c" fn uv_cond_destroy(cond: ?*uv_cond_t) void;
pub extern "c" fn uv_cond_signal(cond: ?*uv_cond_t) void;
pub extern "c" fn uv_cond_broadcast(cond: ?*uv_cond_t) void;
pub extern "c" fn uv_barrier_init(barrier: ?*uv_barrier_t, count: c_uint) c_int;
pub extern "c" fn uv_barrier_destroy(barrier: ?*uv_barrier_t) void;
pub extern "c" fn uv_barrier_wait(barrier: ?*uv_barrier_t) c_int;
pub extern "c" fn uv_cond_wait(cond: ?*uv_cond_t, mutex: ?*uv_mutex_t) void;
pub extern "c" fn uv_cond_timedwait(cond: ?*uv_cond_t, mutex: ?*uv_mutex_t, timeout: c_int) c_int;
pub extern "c" fn uv_once(guard: ?*uv_once_t, callback: ?*const fn () void) void;
pub extern "c" fn uv_key_create(key: ?*uv_key_t) c_int;
pub extern "c" fn uv_key_delete(key: ?*uv_key_t) void;
pub extern "c" fn uv_key_get(key: ?*uv_key_t) ?*anyopaque;
pub extern "c" fn uv_key_set(key: ?*uv_key_t, value: ?*anyopaque) void;
pub extern "c" fn uv_gettimeofday(tv: ?*uv_timeval64_t) c_int;
pub extern "c" fn uv_thread_create(tid: ?*uv_thread_t, entry: *const uv_thread_cb, arg: ?*anyopaque) c_int;
pub extern "c" fn uv_thread_create_ex(tid: ?*uv_thread_t, params: ?*const uv_thread_options_t, entry: *const uv_thread_cb, arg: ?*anyopaque) c_int;
pub extern "c" fn uv_thread_self() uv_thread_t;
pub extern "c" fn uv_thread_join(tid: ?*uv_thread_t) c_int;
pub extern "c" fn uv_thread_equal(t1: ?*const uv_thread_t, t2: ?*const uv_thread_t) c_int;
pub extern "c" fn uv_loop_get_data(_2551527505: ?*const uv_loop_t) ?*anyopaque;
pub extern "c" fn uv_loop_set_data(_437633839: ?*uv_loop_t, data: ?*anyopaque) void;
